# -*- coding: utf-8 -*-
"""0D復習②_手書き数字認識.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/19tDTTVmn598mOrftCydX6ntKnRlMKAcm
"""

import sys, os
sys.path.append(os.pardir)#親ディレクトリのファイルをインポートするための設定
from dataset.mnist import load_mnist

#データの呼び出し
(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)

#それぞれのデータの形状を出力
print(x_train.shape)
print(t_train.shape)
print(x_test.shape)
print(t_test.shape)

# coding: utf-8
import sys, os
sys.path.append(os.pardir)  # 親ディレクトリのファイルをインポートするための設定
import numpy as np
from dataset.mnist import load_mnist
from PIL import Image


def img_show(img):
    pil_img = Image.fromarray(np.uint8(img))
    pil_img.show()

(x_train, t_train), (x_test, t_test) = load_mnist(flatten=True, normalize=False)

img = x_train[0]
label = t_train[0]
print(label)  # 5

print(img.shape)  # (784,)
img = img.reshape(28, 28)  # 形状を元の画像サイズに変形
print(img.shape)  # (28, 28)

img_show(img)
#訓練用の画像を表示

# coding: utf-8
import sys, os
sys.path.append(os.pardir)  # 親ディレクトリのファイルをインポートするための設定
import numpy as np
import pickle
from dataset.mnist import load_mnist
#from common.functions import sigmoid, softmax


def get_data():
    (x_train, t_train), (x_test, t_test) = load_mnist(normalize=True, flatten=True, one_hot_label=False)
    return x_test, t_test


def init_network():
    with open("sample_weight.pkl", 'rb') as f:
        network = pickle.load(f)
    return network

def sigmoid(x):
  return 1 / (1 + np.exp(-x))

def  relu(x):
  return np.maximum(0, x)

def softmax(x):
  c = np.max(x)
  exp_a = np.exp(x - c)
  sum_exp_a = np.sum(exp_a)
  y = exp_a / sum_exp_a

  return y

def predict(network, x):
    W1, W2, W3 = network['W1'], network['W2'], network['W3']
    b1, b2, b3 = network['b1'], network['b2'], network['b3']

    a1 = np.dot(x, W1) + b1
    z1 = sigmoid(a1)
    #z1 = relu(a1)
    a2 = np.dot(z1, W2) + b2
    z2 = sigmoid(a2)
    #z2 = relu(a2)
    a3 = np.dot(z2, W3) + b3
    y = softmax(a3)
    #y = sigmoid(a3)

    return y


x, t = get_data()
network = init_network()
accuracy_cnt = 0
for i in range(len(x)):   #len：引数に指定したオブジェクトの長さや要素数を取得
    y = predict(network, x[i])
    p= np.argmax(y) # 最も確率の高い要素のインデックスを取得
    if p == t[i]:#正解ラベルt[i]と比較
        accuracy_cnt += 1

print("Accuracy:" + str(float(accuracy_cnt) / len(x)))

